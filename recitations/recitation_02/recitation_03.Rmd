---
title: "Recitation 3"
author: "Gokul Sampath"
date: "03/03/2021"
output:
  beamer_presentation:
    slide_level: 2
    theme: Boadilla
    keep_tex: yes
  slidy_presentation: default
  ioslides_presentation: default
subtitle: |
  | 11.220, Spring 2021
  | Modified from Dan Engelberg and Benjamin Preis
classoption: t
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,hold=TRUE,warning=FALSE,message = FALSE,cache=TRUE,
                     root.dir = normalizePath("/Users/ggsam/Dropbox/QR (2019)/Recitations/3/2021/recitation3"))


```

## Agenda
\tableofcontents[hideallsubsections]

## Learning Objectives

- Familiarization with booleans and conditional means. 

- Explore and visualize data using graphs and plots.

- Review introductory coding skills


# Class Norms

## Before Recitation

- Check Canvas for announcements.

- Create a folder for the week.

- Load any data/materials into the folder.

- Create an R script for the week (use same folder).


# More R Skills


## Booleans

- Boolean are variables that have only two cases, TRUE or FALSE.


- Sometimes you use booleans if you only want to deal with data that meets the true/false criteria you set out, as we'll see later.


- You're used to booleans in your everyday life: is something equal to something else? Is it unequal? Less than, greater than? 

## Booleans as a Comparator

Boolean statements can be returned by R when evaluating functions. Here we we are evaluation "<" or "less than"

\small
```{r, echo=TRUE}
3<2
```

## Booleans with Lists

Booleans can also be returned for lists. 

\small
```{r, echo= TRUE}
x <- c(1,2,6,8,10)
x<3
```

- Lists/vectors of booleans can be created and stored in objects.
\small
```{r, echo= TRUE}
y <- c(TRUE, TRUE, FALSE, FALSE)
y
```

## Boolean Syntax

:::.{block}
### Boolean Symbols
 To use booleans, you have to turn your ideas into symbols R can understand. You'll use the following symbols in boolean statements:
 
  - $\mathtt{>}$, "greater than"
  
  - $\mathtt{>=}$, "greater than or equals to"
  
  - $\mathtt{<}$, "less than"
  
  - $\mathtt{<=}$, "less than or equals to"
  
  - $\mathtt{==}$, "equals to" (note the **two** equal signs)
  
  - $\mathtt{!=}$, "not equal to"
  
  - $\mathtt{\&}$, "and"
  
  - $\mathtt{|}$, "or"
:::

## Booleans
Booleans can be linked together using logical statements like "or" (|) and "and" (&).

For example: "two is less than three and four equals five". To do so:
\small
```{r}
(2<3) & (4==5)
```
On the other hand, "two is less than three *or* four equals five" would be:

```{r}
(2<3)|(4==5)
```

Lastly: eight is not equal to 9 *and* five is greater than 4.

```{r}
(8!=9)&(5>4)
```

## Filtering Data

Filtering data is a useful way of looking at only the data that you care about and determining statistics for that data. Filtering allows you to tell R to apply a function only to the portion of data you specify.

- Why Filter? Maybe you think some of the data is corrupted, or you only care about a certain sector of the population (ie. particular income group, gender, etc..

- You'll often use booleans when filtering data.

## Applying Code to Filter Data

:::{.block}
### Filtering Data Options
- Use the $\mathtt{subset()}$ function from base R.
:::

```{r, echo=TRUE}
x

subset(x, x>5)
```


## Conditional Means I

Let's use a built in data set from R, "CO2," which has information on carbon dioxide uptake in gas plants. There are 12 different plants, originating from either Quebec or Mississippi. Let's take a look:

```{r, echo=TRUE}
head(CO2)
```
## Conditional Means II

Now, it's possible to take the average uptake simply by doing:

```{r, echo=TRUE}
mean(CO2$uptake)
```

## Conditional Means II

But, what if we wanted to know the average uptake for each plant? Use a conditional statement using the $\mathtt{tapply()}$ function from base R.

\small

```{r}
tapply(CO2$uptake,CO2$Plant,mean)
```


## Conditional Means III
- If you only wanted to condition on numeric values, rather than categorical values, you could use a statement like this, to get the average uptake conditional on lower conditional ambient carbon dioxide.

```{r, echo=TRUE}
mean(CO2[CO2$conc<350,]$uptake,na.rm=T)
```
## Conditional Summary

You can also get a summary of each gas plant using the tapply() function.

```{r, echo=TRUE}
tapply(CO2$uptake,CO2$Plant,summary)
```


## Dealing with Missing and Infinite values

Missing values in R are listed as "NA". NA values can be a major headache, as they frequently interfere with numerical functions (like sum and median).

::: {.block}
### NA Values
- The function "is.na()" can be used to see if a value is NA
- Functions, like sum() have na.rm options.
:::

::: {.block}
### Infinite Values
- In addition to NA values, sometimes you'll come across Infinite values.
- In this instance, use the is.infinite()} function.
:::

## Dealing with NA values

A small example of NA values

\small
```{r, echo=TRUE}
x <- c(1,2,6,8,NA,10)
```   
\normalsize

What does is.na() do?

\small
```{r, echo=TRUE}
is.na(x)
```

## Dealing with NA values II

\normalsize

NA values often disrupt math functions in R. How does an NA value interfere with $\mathtt{mean()}$?

\small
```{r, echo=TRUE}
mean(x)
mean(x,na.rm = T)
```
\normalsize

# Continuing to explore and visualize data

For this recitation we are going to Boston Building Permit Data, cleaned beforehand for some ease of use!

- Note: Boston puts a lot of their data online at data.boston.gov, which is a great resource for those looking for research data sets.

## Reading in the data

- When reading in a file, like a $\mathtt{csv}$ file, you can tell R the type of variable each column is.

- For example, when dealing with Census or ZIP Code data, this can help as many areas begin with "0" and would be read in incorrectly if you don't specify.

- By default, R reads in "strings" (characters) as "factors" which is sometimes helpful, sometimes frustrating, when dealing with character data. I almost always use the $\mathtt{stringsAsFactors=FALSE}$ command when I read in a csv. 

## Whats a Factor

What are factor type variables and what do they do? Remember...this is one of the variable types we discussed previously (ie. strings, numeric, booleans, etc.)


## Whats a Factor: Answered

Conceptually, factors are variables in R which take on a limited number of different values; such variables are often refered to as categorical variables.

## Reading in the data II
R allows you to import Excel/CSV files into R studio. CSV means: Comma Separated Value.
\small
```{r, echo=TRUE, eval=FALSE}
bos_permits<-read.csv("Boston_Building_Permits.csv",
                 stringsAsFactors = FALSE,
                  colClasses = c("permitnumber"="character",
                                 "zip"="character"))
```
\normalsize

- Whenever you load a new data set, it is helpful to use the $\mathtt{str}$ command to get a sense of the dimensions and types of data you've just imported.

## Boston Permit Data

```{r, include=FALSE}
library(dplyr)
bos_permits<-bos_permits%>%
  select(-X)%>%
  filter(occupancytype!=" "&occupancytype!="VacLd"&occupancytype!="Comm"&total_fees<500)%>%
  filter(description=="Electrical"|description=="Gas"|description=="Interior/Exterior Work"|description=="Plumbing"|description=="Fire Alarm")
```
\tiny
```{r,echo=TRUE}
str(bos_permits)
```
\normalsize

## Boston Permit Data

- This data set provides a wealth of information on Boston buildings. 

- The permits telling you the valuation of the building change, fees, owner, address, and parcel information.

- For simplicity, we're going to ask: what is the relationship between type of building and Permit Description

## Boston Permit Data
- Before we begin making tables, it's good practice to look at just the variables of interest to make sure nothing is awry.

\small
```{r}
unique(bos_permits$occupancytype)
unique(bos_permits$description)
```
\normalsize

## Making tables and checking frequencies

To start, let's look at the housing stock in the permit data by occupancy type. We will be using the xtable package again.

\small
```{r}
library(xtable)
xtabs(~occupancytype,bos_permits)
```

## Making tables and checking frequencies

We can also compare two variables against each other. Here we are comparing occupancytype and description.
```{r,echo=TRUE}
xtabs(~description+occupancytype,bos_permits)
```


## Quantiles

Now, the Boston Permit data includes information on the amount of permit fees charged, and we may want to get a sense of whether they differ for different types of permits.

## Quantiles II

First, let's get a summary of the fees

\small
```{r, echo=TRUE}
summary(bos_permits$total_fees)
```

## Quantiles III

Let's say we wanted to know the amount of the fee at the 20th, 40th, 60th, and 80th percentile (the quintiles), to do so, we'd use the quantile function.

```{r}
quantile(bos_permits$total_fees,probs=c(.2,.4,.6,.8))
```

## Quantiles with Nested Function

You can combine the $\mathtt{seq}$ function that we saw in recitation 1 to make this a little easier:

```{r}
quantile(bos_permits$total_fees,probs=seq(.2,.8,by=.2))
```

## Box plots

- Maximum fee was \$495.0, but the median is only \$46, it sure seems like we have a rightward-distribution of the data.

- Positive or right skewed data.

- Box plots allow us to see much more than your usual $\mathtt{summary()}$ function. 

## Box plots

The code below shows you how to make a single box plot for the data on permit fees.

\small
```{r, echo=TRUE, eval=FALSE}
boxplot(bos_permits$total_fees,
        main = "How much were building permit fees?")
```


## Box plots

\small
```{r, echo=FALSE, eval=TRUE, height=5.5}
boxplot(bos_permits$total_fees,
        main = "How much were building permit fees?")
```

## Box plots

And now a box plot with the fees broken out by type of building.

- *Note*: Remember that the order to put the data in matter a lot. The data on the left of the tilde will be on the y axis. This is usually reserved for your dependent variable.

\small
```{r,fig.height=5.5,eval=FALSE}
boxplot(bos_permits$total_fees~bos_permits$occupancytype,
        main = "How much were building permit fees,by building type?")
```

## Box Plots
```{r,echo=FALSE}
boxplot(bos_permits$total_fees~bos_permits$occupancytype,
        main = "How much were building permit fees, by building type?")
```

## Comparing data to a normal curve on a plot I

- When we graph our data its usually easy to eyeball whether the data looks to be normally distributed.

- We do this on the next slide with the data on the permit fees.

- Notice the vertical line at the mean, R allows us to add lines to graphs.

- If the two lines are very different, then we know the data is skewed.

## Comparing data to a normal curve on a plot II

\small
```{r,fig.height=5}
mean.fees <- mean(bos_permits$total_fees) #get the mean

plot(density(bos_permits$total_fees),
     main = "How much are building permit fees?")
abline(v = mean.fees, col = "red") #plot the mean
```

## Comparing Data to a Normal Curve

Now, the data is pretty obviously skewed. Let's zoom in on the data for buildings with fees less than $100.

- To zoom in on the data, we're going to use a Boolean statement, using the $\mathtt{subset}$ function to filter for observations with less than $100

```{r}
bos_permits_subset<-subset(bos_permits,total_fees<100)
```

## Comparing Data to a Normal Curve

\small
```{r}
#Mean Fees Amount
mean.fees <- mean(bos_permits_subset$total_fees)
#Fee Standard Deviation
sd.fees <- sd(bos_permits_subset$total_fees)
```
In order to add a normal curve to our plot, we first need to generate the density that we *would expect if the data were normal.* To do so, we:

- Create a sequence for the range of your data
- Generate the normal distribution using $\mathtt{dnorm()}$
- Add that curve to your plot
- Remember to set the argument *add = TRUE* so that we don't start a new plot from scratch.

\small
```{r,eval=FALSE}
x <- seq(0, 100, 10)
plot(density(bos_permits_subset$total_fees),
     main = "How much are building permit fees?")
abline(v = mean.fees, col = "red") #plot the mean
curve(dnorm(x, mean = mean.fees, sd = sd.fees),
      col = "blue", lwd = 2, add=TRUE, yaxt="n") #plotting normal
```

## Comparing Data to a Normal Curve

```{r,eval=TRUE,echo=FALSE}
x <- seq(0, 100, 10)
plot(density(bos_permits_subset$total_fees),
     main = "How much are building permit fees?")
abline(v = mean.fees, col = "red") #plot the mean
curve(dnorm(x, mean = mean.fees, sd = sd.fees),
      col = "blue", lwd = 2, add=TRUE, yaxt="n") #plotting density of normal
```

## Creating New Variables and Assigning Them a Value

- Often the variables in the data are not the exact variables we want to analyze. We might want to:
  - turn a continuous variable into integers or a dummy,
  - convert the units of a variable (as in recitation 1),
  - assign numeric values to a categorical variable, or
  - combine two number variables into a single variable.

- How we do this depends on the value we want?

## Creating New Variables and Assigning Them a Value II

- We create a new variable in our data set by assigning a field name that isn't yet used.
- To do so, we create a dummy variable, and then update the value in a series of commands.
- We also use the $\mathtt{ifelse()}$ function to take advantage of the Boolean statements that we practiced earlier. The first argument is always a *Boolean* statement. When that statement is true, then the function returns argument 2. If the function is false it returns argument 3.

## Creating New Variables and Assigning Them a Value

\small
```{r}
#Using $ Syntax
bos_permits$fee_quartile<-bos_permits$total_fees

bos_permits$fee_quartile<-
  ifelse(bos_permits$total_fees<30,1,bos_permits$fee_quartile)

bos_permits$fee_quartile<-
  ifelse(bos_permits$total_fees>=30&bos_permits$total_fees<46.27,2,
         bos_permits$fee_quartile)

bos_permits$fee_quartile<-
  ifelse(bos_permits$total_fees>=46.27&bos_permits$total_fees<90,3,
         bos_permits$fee_quartile)

bos_permits$fee_quartile<-
  ifelse(bos_permits$total_fees>=90,4,bos_permits$fee_quartile)
```

## Creating New Variables and Assigning Them a Value

- You can use booleans and ifelse statements to make increasingly specific variables. Think about how to combine these three functions to create a variable that says whether an observation is above the mean but below the median?

\small
```{r,echo=FALSE}
head(bos_permits%>%select(applicant,total_fees,fee_quartile),15)
```

# R Coding Practice

For this exercise you will be working with your partner in the seat next to you. 
You have 20 minutes to complete this R exercise, but do not worry if you can't finish  the last question
within the time limit. Please raise your hand if you have questions, but try to work through the coding challenges with only 
your partners help as far as possible.


## Question 1 - Learn your partners name.

A. Ask your partner for their first name. Store the name in an object called pname. Them, generate a an object called pname_length containing the number of characters in the name. 

B. Is the length of your partner’s name less than 5 characters? Test the length of the name using a logical operator, and store the resulting boolean (True/False) in an object named lessthan5.When you are done, display the results.

## Question 1A - Answer

A.)
```{r, echo=TRUE}
pname <- "gokul" 
##generate object type string containing the name

 pname_length <- nchar(pname) ## store length in new object.
 pname_length
```
## Question 1B Answer
B.)
```{r, echo=TRUE}
lessthan5<- pname_length<5 ## Use logical operator to return boolean (True/False).
lessthan5 ##Result
```


## Question 2: DUSP Progream Groups and Vectors in R

Let’s say that in 2008 there were 8 students in IDG, 15 students in CDD, 10 students in EPP, and 7 students in HCED at DUSP. In 2009, IDG enrolled 4 students, CDD 13 students, EPP 13 students, and HCED 9 students. Let’s compare whether the number of students enrolled in each group increased, decreased, or doubled between 2008 and 2009, and store the results as vectors called increased and doubled respectively.

Create the following vectors, for all vectors use the IDG, CDD, EPP, and HCED acronyms where relevant.

- 2008, 2009 - Vectors containing the number of students in each group.

- groups - Vector containing the names of each group in order (IDG< CDD, EPP, and HCED).

- increase - a vector of booleans containing information on whether the number of students increased between 2008 and 2009.

- doubled - A vector of booleans containing information on whether the number of students in each group doubled between 2008 and 2009.

## Question 2 - Answered

```{r}

groups<- c("IDG","CDD","EPP","HCED")
groups ## Create a vector containing the names of the groups.

yr_2008<-c(8,15, 10,7)
yr_2008 ## Year 2008 enrollment

yr_2009<-c(4,13,13,9)
yr_2009 ## Year 2009 enrollment

increased<-yr_2009<yr_2008 ##increases by group

doubled= yr_2009>=2*yr_2008 ##doubled by group
```

## Question 3 - Create a data frame
Use the table below to create a data frame for all four years (2008-2012), use the data.frame() function. Then, calculate the average enrollment over the four years and store it as a vector, along with the stdev of the enrollment. Finally add these to your data frame. Use the head() fuction to check to see if your data frame looks correct.

See table in handout.

## Question 3 - Answered 

```{r}

yr_2010<-c(6,13,14,9) ## Create enrollment data for 2010&2011
yr_2011<-c(9,14,19,7)
##Make data frame
DUSP<-data.frame(groups, yr_2008, yr_2009, yr_2010, yr_2011)
##Use -1 to dis-include the first column.
DUSP$average<-rowMeans(DUSP[,-1], na.rm = TRUE)

```
## Question 3 - Answered 

```{r, echo=TRUE}
DUSP
```

## Review

In this recitation we covered:

- Using Booleans to calculate conditional means, filter data

- Exploring and visualizing data using graphs and plots.

- Practicing introductory coding skills

Next recitation we will introduce probability!
